/* Generated By:JavaCC: Do not edit this line. GrammarHbVar.java */
package grammarHbVar;

import user.*;
import java.util.*;
import java.io.*;



import mutationStructures.*;
import helpers.*;

import java.lang.Object;

public class GrammarHbVar implements GrammarHbVarConstants {
   /*Function that returns an ArrayList of all mutations read on the Web Page after parsing
   * (with the grammar)*/
  public MutationList grammarParsing() throws ParseException,FileNotFoundException
  {
    //System.out.println("read file: ");

    int i=1;
    ArrayList<Integer> lineIndex = new ArrayList<Integer>();
    ArrayList<Mutation> listMutation=new ArrayList<Mutation>();

      try
      {


        while(true){
        // System.out.println(" ");
        //System.out.println("line: "+i);


                        Entry entry=GrammarHbVar.one_line();



                        if((entry.getName()).equals("newLine")){
                          //System.out.println("jump line.");
                  i++;
                        }else if((entry.getName()).equals("EOF")){
                          //System.out.println("Parsing terminated.");
                  break;
                        }
                        else if((entry.getName()).equals("unexpected")){
                          //System.out.println("unexpected term.");
                          lineIndex.add(i);//keep the number of the line not read in order to display ignored lines
                  i++;
                        }else{
                          //System.out.println("Line parsed. i="+ i);
                          listMutation.addAll(entry.getMutations());
                  i++;
                        }
                }

      }

      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
      }

      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
      }




                MutationList mutationList = new MutationList(lineIndex, listMutation);//return ignored lines and mutations created
                return mutationList;
  }
          //in case the compiler encounters a line which is not included in the grammar, it continues reading tokens
          //until the the token kind with is end of the line in our case
      static void error_skipto(int kind) {
          ParseException e = generateParseException();  // generate the exception object.
          //System.out.println(e.toString());  // print the error message
          Token t;
          do {
            t = getNextToken();
          } while (t.kind != kind);

        }

/*the columns name, mutation and hgvsname are separated by separator*/
  static final public void separator() throws ParseException {
    jj_consume_token(14);
  }

  static final public String or() throws ParseException {
  String s;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 15:
      jj_consume_token(15);
         {if (true) return "or";}
      break;
    case 16:
      jj_consume_token(16);
                 {if (true) return "OR";}
      break;
    case 17:
      jj_consume_token(17);
                 {if (true) return "Or";}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String and() throws ParseException {
  String s;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 18:
      jj_consume_token(18);
         {if (true) return "AND";}
      break;
    case 19:
      jj_consume_token(19);
                 {if (true) return "and";}
      break;
    case 20:
      jj_consume_token(20);
                 {if (true) return "And";}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*with one_line we parse one line and return an object of type Entry*/
  static final public Entry one_line() throws ParseException {
  Entry entry;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case NUMBER:
      case LETTER:
      case HYPHENE:
      case CHANGETO:
      case PARENTHESIS:
      case SYMBOLS:
      case DOLLAR:
      case UNEXPECTED:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
        entry = entry();
        jj_consume_token(nextline);
                    {if (true) return entry;}
        break;
      case nextline:
        jj_consume_token(nextline);
                    {if (true) return new Entry("newLine");}
        break;
      case 0:
        jj_consume_token(0);
                    {if (true) return new Entry("EOF");}
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                error_skipto(nextline);
                {if (true) return new Entry("unexpected");}
    }
    throw new Error("Missing return statement in function");
  }

  static final public String insideParenthesis() throws ParseException {
  Token t;//t is an image and that is why for its recovery we use .image
  StringBuilder txt = new StringBuilder();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNEXPECTED:
        jj_consume_token(UNEXPECTED);
        break;
      case DIGIT:
        t = jj_consume_token(DIGIT);
         txt = txt.append(t.image);
        break;
      case LETTER:
        t = jj_consume_token(LETTER);
         txt = txt.append(t.image);
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
                 txt = txt.append(t.image);
        break;
      case HYPHENE:
        t = jj_consume_token(HYPHENE);
                 txt = txt.append(t.image);
        break;
      case SYMBOLS:
        t = jj_consume_token(SYMBOLS);
                 txt = txt.append(t.image);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case NUMBER:
      case LETTER:
      case HYPHENE:
      case SYMBOLS:
      case UNEXPECTED:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_1;
      }
    }
         {if (true) return txt.toString();}
    throw new Error("Missing return statement in function");
  }

  static final public String texte() throws ParseException {
  Token t;
  StringBuilder txt = new StringBuilder();
  String s;
  AminoAcid amino;
  Protein prot;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOLLAR:
        jj_consume_token(DOLLAR);
           txt = txt.append(" ");
        break;
      case UNEXPECTED:
        t = jj_consume_token(UNEXPECTED);
        break;
      case SYMBOLS:
        t = jj_consume_token(SYMBOLS);
                         txt = txt.append(t.image);
        break;
      case CHANGETO:
        t = jj_consume_token(CHANGETO);
                         txt = txt.append(t.image);
        break;
      case HYPHENE:
        t = jj_consume_token(HYPHENE);
                         txt = txt.append(t.image);
        break;
      case PARENTHESIS:
        t = jj_consume_token(PARENTHESIS);
                                           txt = txt.append(t.image);
        break;
      case LETTER:
        t = jj_consume_token(LETTER);
                                      txt = txt.append(t.image);
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
                                      txt = txt.append(t.image);
        break;
      case DIGIT:
        t = jj_consume_token(DIGIT);
                                     txt = txt.append(t.image);
        break;
      case 15:
      case 16:
      case 17:
        s = or();
                                  txt = txt.append(s);
        break;
      case 18:
      case 19:
      case 20:
        s = and();
                                   txt = txt.append(s);
        break;
      case 21:
        jj_consume_token(21);
                               txt = txt.append("Hb");
        break;
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
        prot = proteinchain();
                                      txt = txt.append(txt.append(prot.getNameHbVar()));
        break;
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
        amino = aminoAcid();
                                             txt = txt.append(amino.getName());
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case NUMBER:
      case LETTER:
      case HYPHENE:
      case CHANGETO:
      case PARENTHESIS:
      case SYMBOLS:
      case DOLLAR:
      case UNEXPECTED:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
    }
                         {if (true) return txt.toString();}
    throw new Error("Missing return statement in function");
  }

  static final public AminoAcid aminoAcid() throws ParseException {
  String s;
  AminoAcid amino;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 22:
      jj_consume_token(22);
                s = "Glu";
      break;
    case 23:
      jj_consume_token(23);
                s = "Asp";
      break;
    case 24:
      jj_consume_token(24);
                s = "Ala";
      break;
    case 25:
      jj_consume_token(25);
                s = "Arg";
      break;
    case 26:
      jj_consume_token(26);
                s = "Asn";
      break;
    case 27:
      jj_consume_token(27);
                s = "Cys";
      break;
    case 28:
      jj_consume_token(28);
                s = "Gln";
      break;
    case 29:
      jj_consume_token(29);
                s = "Gly";
      break;
    case 30:
      jj_consume_token(30);
                s = "His";
      break;
    case 31:
      jj_consume_token(31);
                s = "Ile";
      break;
    case 32:
      jj_consume_token(32);
                s = "Leu";
      break;
    case 33:
      jj_consume_token(33);
                s = "Lys";
      break;
    case 34:
      jj_consume_token(34);
                s = "Met";
      break;
    case 35:
      jj_consume_token(35);
                s = "Phe";
      break;
    case 36:
      jj_consume_token(36);
                s = "Pro";
      break;
    case 37:
      jj_consume_token(37);
                s = "Ser";
      break;
    case 38:
      jj_consume_token(38);
                s = "Thr";
      break;
    case 39:
      jj_consume_token(39);
                s = "Trp";
      break;
    case 40:
      jj_consume_token(40);
                s = "Tyr";
      break;
    case 41:
      jj_consume_token(41);
                s = "Val";
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         amino = new AminoAcid(s);
          {if (true) return amino;}
    throw new Error("Missing return statement in function");
  }

  static final public Protein proteinchain() throws ParseException {
  Token t;
  String s;
  Protein prot;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 42:
      jj_consume_token(42);
                            s = "Ggamma";
      break;
    case 43:
      jj_consume_token(43);
                            s = "Agamma";
      break;
    case 44:
      jj_consume_token(44);
                         s = "delta";
      break;
    case 45:
      jj_consume_token(45);
                        s = "beta";
      break;
    case 46:
      jj_consume_token(46);
                          s = "alpha1";
      break;
    case 47:
      jj_consume_token(47);
                          s =  "alpha2";
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          prot = new Protein(s);
          {if (true) return prot;}
    throw new Error("Missing return statement in function");
  }

  static final public String number() throws ParseException {
  String num = "";
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      t = jj_consume_token(NUMBER);
                 num = t.image;
      break;
    case DIGIT:
      t = jj_consume_token(DIGIT);
                 num = t.image;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return num;}
    throw new Error("Missing return statement in function");
  }

/*<PARENTHESIS> txt <PARENTHESIS>*/
  static final public String index1() throws ParseException {
  String indTxt = " ";
    jj_consume_token(PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case NUMBER:
    case LETTER:
    case HYPHENE:
    case SYMBOLS:
    case UNEXPECTED:
      indTxt = insideParenthesis();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(PARENTHESIS);
   {if (true) return indTxt;}
    throw new Error("Missing return statement in function");
  }

/*<PARENTHESIS> num <PARENTHESIS>*/
  static final public int index2() throws ParseException {
  String indNum;
    jj_consume_token(PARENTHESIS);
    indNum = number();
    jj_consume_token(PARENTHESIS);
   {if (true) return Integer.valueOf(indNum);}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<Protein> protein() throws ParseException {
  Protein p1, p2;
  ArrayList<Protein> proteinPair = new ArrayList<Protein>();
    p1 = proteinchain();
         proteinPair.add(p1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 15:
    case 16:
    case 17:
      or();
      p2 = proteinchain();
                 proteinPair.add(p2);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
          {if (true) return proteinPair;}
    throw new Error("Missing return statement in function");
  }

  static final public AminoAcidSeq aminoAcidSequence() throws ParseException {
        ArrayList<AminoAcid> seq = new ArrayList<AminoAcid>();
        AminoAcid amino;
    amino = aminoAcid();
                seq.add(amino);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HYPHENE:
      label_3:
      while (true) {
        jj_consume_token(HYPHENE);
        amino = aminoAcid();
                seq.add(amino);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HYPHENE:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_3;
        }
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
          AminoAcidSeq seqClass = new AminoAcidSeq(seq);
          {if (true) return seqClass;}
    throw new Error("Missing return statement in function");
  }

  static final public AminoAcidSeq aminoAcidSequenceReverse() throws ParseException {
        ArrayList<AminoAcid> seq = new ArrayList<AminoAcid>();
        AminoAcid amino;
    label_4:
    while (true) {
      amino = aminoAcid();
      jj_consume_token(HYPHENE);
                        seq.add(amino);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      amino = aminoAcid();
                        seq.add(amino);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
          AminoAcidSeq seqClass = new AminoAcidSeq(seq);
          {if (true) return seqClass;}
    throw new Error("Missing return statement in function");
  }

/*the two cases replacement and replace with*/
/*replacement : Hb F-Meinohama Ggamma 5(A2) Glu>Gly HBG2:c.17A>G */
/*replace with: Hb Antalya beta 2 - 5 His-Leu-Thr-Pro replaced with His-Ser-Asp-Ser HBB:c.[16delC;8_9insC]*/
  static final public MutationType replaceSet(Header header, AminoAcidSeq seqOld) throws ParseException {
  Replacement replace;
  AminoAcidSeq seqNew;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHANGETO:
      jj_consume_token(CHANGETO);
      seqNew = aminoAcidSequence();
      break;
    case 48:
      jj_consume_token(48);
      seqNew = aminoAcidSequence();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         replace = new Replacement(header, seqOld, seqNew);
         {if (true) return replace;}
    throw new Error("Missing return statement in function");
  }

/*add an interval of amino acids*/
/*example: Hb Zunyi beta 147, Stop>Gln; modified C-terminal sequence: (147)Gln-Ala-Arg-Phe-Leu-Ala-Val-Gln-Phe-Leu-Leu- Lys-Val-Pro-Leu-Phe-Pro-Lys-Ser-Asn-(167)Tyr-COOH HBB:c.442T>C*/
  static final public AddChain addChain(Header header) throws ParseException {
  AddChain addChain;
  AminoAcidSeq seq;
  AminoAcid amino;
    jj_consume_token(SYMBOLS);
    jj_consume_token(49);
    jj_consume_token(HYPHENE);
    jj_consume_token(50);
    jj_consume_token(SYMBOLS);
    index2();
    seq = aminoAcidSequenceReverse();
    index2();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      amino = aminoAcid();
      jj_consume_token(HYPHENE);
                                      seq.add(amino);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(51);
         addChain = new AddChain(header, seq);
         {if (true) return addChain;}
    throw new Error("Missing return statement in function");
  }

/*add one amino acid or an interval(addChain or AddAcid)*/
  static final public MutationType addSet(Header header) throws ParseException {
  MutationType mutationType;
  AminoAcid amino;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 52:
      jj_consume_token(52);
      break;
    case 53:
      jj_consume_token(53);
      break;
    case 54:
      jj_consume_token(54);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CHANGETO);
    amino = aminoAcid();
          mutationType = new AddAcid(header, amino);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOLS:
      mutationType = addChain(header);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
         {if (true) return mutationType;}
    throw new Error("Missing return statement in function");
  }

/*all mutations that contain ->,such mutations can have one deleted amino acid or an interval of them*/
/*example : Hb Bakersfield***alpha1 50(CE8) His->0*/
/*when a sequence of amino acids is deleted, it can be replaced by another sequence*/
/*example : Hb Pohnpei***alpha2 137(H20) - 138(H21) Thr-Ser->0 AND inserted Thr*/
  static final public MutationType deleteSet(Header header, AminoAcidSeq seq) throws ParseException {
  DeleteSet delete;
  Boolean inserted = false;
  AminoAcid aminoInserted;
    jj_consume_token(55);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 56:
    case 57:
    case 58:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
        jj_consume_token(56);
        break;
      case 57:
        jj_consume_token(57);
        break;
      case 58:
        jj_consume_token(58);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      aminoInserted = aminoAcid();
                 inserted = true;
                  delete = new DeleteSet(header, seq, inserted, aminoInserted);
                 {if (true) return delete;}
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
     delete = new DeleteSet(header, seq);
    {if (true) return delete;}
    throw new Error("Missing return statement in function");
  }

/*A set that contains the mutations replaceSet, deleteSet*/
  static final public MutationType modify(Header header) throws ParseException {
  AminoAcidSeq seq;
  MutationType mutationType;
    seq = aminoAcidSequence();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHANGETO:
    case 48:
      mutationType = replaceSet(header,seq);
      break;
    case 55:
      mutationType = deleteSet(header,seq);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return mutationType;}
    throw new Error("Missing return statement in function");
  }

/*contains protein [or protein] index(text) [- index(text)] */
  static final public Header header() throws ParseException {
  //elements which help recovery
  int firstIndNum,lastIndNum;
  String firstIndTxt="",lastIndTxt="",tempFirstIndNum="0",tempLastIndNum="0";//initialisation must be done
  Header header;
    //can be just one number or an interval
            tempFirstIndNum = number();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOLS:
      jj_consume_token(SYMBOLS);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARENTHESIS:
      firstIndTxt = index1();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HYPHENE:
      jj_consume_token(HYPHENE);
      tempLastIndNum = number();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARENTHESIS:
        lastIndTxt = index1();
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
          firstIndNum = Integer.valueOf(tempFirstIndNum);
          lastIndNum = Integer.valueOf(tempLastIndNum);
         header = new Header(firstIndNum, firstIndTxt, lastIndNum, lastIndTxt);
         {if (true) return header;}
    throw new Error("Missing return statement in function");
  }

/*the mutation containing inserted between*/
/*example: Hb Bronx Lys-Val-Leu- inserted between codons 68(E12) and 69(E13) of beta HBB:c.207_208insAAAGTGCTC*/
  static final public Insertion insertion() throws ParseException {
  //elements which help recovery
  AminoAcidSeq seq;
  String firstIndTxt="",lastIndTxt="",tempFirstIndNum="",tempLastIndNum="";
  int firstIndNum,lastIndNum;
  ArrayList<Protein> proteinPair = new ArrayList<Protein>();

  //constructor elements
  Header header;
  Insertion insertion;
    /*starts with a sequence of amino acids*/
            seq = aminoAcidSequenceReverse();
    jj_consume_token(59);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 60:
      jj_consume_token(60);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    /*first number*/
            tempFirstIndNum = number();
    /*(txt)*/
            firstIndTxt = index1();
    and();
    /*second number*/
            tempLastIndNum = number();
    /*(txt)*/
            lastIndTxt = index1();
    label_5:
    while (true) {
      jj_consume_token(LETTER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LETTER:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_5;
      }
    }
          firstIndNum = Integer.valueOf(tempFirstIndNum);
          lastIndNum = Integer.valueOf(tempLastIndNum);
          /*call constructor*/
          header = new Header(firstIndNum, firstIndTxt, lastIndNum, lastIndTxt);
          insertion = new Insertion(header, seq);
         {if (true) return insertion;}
    throw new Error("Missing return statement in function");
  }

/*the third column hgvsName*/
  static final public String HGVSname() throws ParseException {
  String s;
    s = texte();
   {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/*the first column: the mutation name*/
  static final public String variantName() throws ParseException {
  StringBuilder name= new StringBuilder();
  String txt;
  Protein prot;
    txt = texte();
                 name.append(txt);
   {if (true) return name.toString();}
    throw new Error("Missing return statement in function");
  }

/*if there is more than one mutationType then type() is called
and it returns the mutationTypes separated by "and" (finds recursively)
there is no need to recover the list of proteins since we do it ione time in mutationType()*/
  static final public ArrayList<MutationType> type() throws ParseException {
        Header header;
        MutationType mutationType;
        ArrayList<MutationType> listOfTypes = new ArrayList<MutationType>();
        ArrayList<MutationType> listOfTypesFound = new ArrayList<MutationType>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      mutationType = insertion();
      protein();
                             listOfTypes.add(mutationType);
      break;
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
      protein();
      header = header();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
        /*mutationType = theory(header) |*/ mutationType = modify(header);
        break;
      case 52:
      case 53:
      case 54:
        mutationType = addSet(header);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                  listOfTypes.add(mutationType);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 18:
    case 19:
    case 20:
      and();
      listOfTypesFound = type();
                 listOfTypes.addAll(listOfTypesFound);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
         {if (true) return listOfTypes;}
    throw new Error("Missing return statement in function");
  }

/*returns a list of mutations*/
/*the example below contains three mutation types with are separated by the ands between them*/
/*inserted between codons 68(E12) AND 69(E13) of beta AND beta 1(NA1) Gly>Cys AND beta 139(H17) Asn->0*/
/*if there are two proteins in the protein list then two mutations are created each one having one of the proteins
for example: beta or alpha 139(H17) Asn->0 returns two mutations:
alpha 139(H17) Asn->0
beta 139(H17) Asn->0 */
  static final public ArrayList<Mutation> mutationType() throws ParseException {
        Header header;
        Mutation mutation;
        ArrayList<Protein> proteinList = new ArrayList<Protein>();
        ArrayList<MutationType> listOfTypes = new ArrayList<MutationType>();
        ArrayList<MutationType> listOfTypesFound = new ArrayList<MutationType>();

        ArrayList<Mutation> mutations = new ArrayList<Mutation>();
        MutationType mutationType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      mutationType = insertion();
      /*proteins*/
                                  proteinList = protein();
                             listOfTypes.add(mutationType);
      break;
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
      proteinList = protein();
      header = header();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
        /*mutationType = theory(header) |*/ mutationType = modify(header);
        break;
      case 52:
      case 53:
      case 54:
        mutationType = addSet(header);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                  listOfTypes.add(mutationType);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 18:
    case 19:
    case 20:
      and();
      listOfTypesFound = type();
                 listOfTypes.addAll(listOfTypesFound);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
          /*create a mutation for every protein*/
                for (Protein protein : proteinList) {
                        mutation = new Mutation(protein,listOfTypes);
                        mutations.add(mutation);
                }

                {if (true) return mutations;}
    throw new Error("Missing return statement in function");
  }

/*returns all mutations in entry*/
/*An entry can have more than one mutation separated by OR*/
/*example: beta 42(CD1) - 44(CD3) Phe-Glu-Ser->0 OR beta 43(CD2) - 45(CD4) Glu-Ser-Phe->0*/
/*each one is counted in its own mutation*/
/*beta 42(CD1) - 44(CD3) Phe-Glu-Ser->0*/
/*beta 43(CD2) - 45(CD4) Glu-Ser-Phe->0*/
/*<mutation OR mutation OR mutation OR >*/
  static final public ArrayList<Mutation> mutation() throws ParseException {
        ArrayList<Mutation> mutationsFound = new ArrayList<Mutation>();
        ArrayList<Mutation> mutations = new ArrayList<Mutation>();
    mutationsFound = mutationType();
                /*add the mutations found to the other mutations*/
                mutations.addAll(mutationsFound);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 15:
    case 16:
    case 17:
      or();
      /*find the other mutations recursively*/
                      mutationsFound = mutation();
                 mutations.addAll(mutationsFound);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
   {if (true) return mutations;}
    throw new Error("Missing return statement in function");
  }

/*entry corresponds to an entry in the database table*/
/*name (separator) mutations (separator) hgvsname*/
/*mutations = mutation or mutation or mutation or....*/
/*mutation = mutatiotype and mutationtype and mutationtype and...*/
  static final public Entry entry() throws ParseException {
        Entry entry;
        String varName, hgvsName="";
        ArrayList<Mutation> mutations = new ArrayList<Mutation>();
    varName = variantName();
    separator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 15:
    case 16:
    case 17:
      or();
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    mutations = mutation();
    separator();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case NUMBER:
    case LETTER:
    case HYPHENE:
    case CHANGETO:
    case PARENTHESIS:
    case SYMBOLS:
    case DOLLAR:
    case UNEXPECTED:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
      hgvsName = HGVSname();
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
        entry = new Entry(varName, mutations,  hgvsName);
        //System.out.println("entry read");
        //display data for every mutation
        //entry.print();

         {if (true) return entry;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public GrammarHbVarTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[38];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x38000,0x1c0000,0xffffbff1,0x29e0,0x29e0,0xffffbfe0,0xffffbfe0,0xffc00000,0x0,0x60,0x29e0,0x38000,0x100,0x100,0xffc00000,0xffc00000,0x200,0xffc00000,0x0,0x800,0x0,0x0,0x200,0x800,0x400,0x400,0x100,0x0,0x80,0xffc00000,0xffc00000,0x1c0000,0xffc00000,0xffc00000,0x1c0000,0x38000,0x38000,0xffffbfe0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0xffff,0x0,0x0,0xffff,0xffff,0x3ff,0xfc00,0x0,0x0,0x0,0x0,0x0,0x3ff,0x3ff,0x10000,0x3ff,0x700000,0x0,0x7000000,0x7000000,0x810000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x7003ff,0xffff,0x0,0x7003ff,0xffff,0x0,0x0,0x0,0xffff,};
   }

  /** Constructor with InputStream. */
  public GrammarHbVar(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public GrammarHbVar(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new GrammarHbVarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public GrammarHbVar(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new GrammarHbVarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public GrammarHbVar(GrammarHbVarTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(GrammarHbVarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[61];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 38; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 61; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
